* SICP 
** 2a.1
A few programs that have a lot in common with each other.
Make some abstractions that are not easy to make in most languages.

First is the sum:

$$ \sum_{i=a}^{b} i $$

(It has a closed form and it is easy to compute,
but we are not interested in that kind of solution here).

You have a base case and a recursive case

you have an easy case you know the answer to or you have to
reduce it to simpler problem.

The subproblem - add up the integers, one fewer integer, and one fewer
again, and once it is solved add a to it and the result is the answer
to the whole problem. 

#+BEGIN_SRC scheme 
(define (sum-int a b)
  (if (> a b)
    0
    (+ a (sum-int (+ a 1) b))))
#+END_SRC

Recursive function but no tail position
#+BEGIN_SRC javascript
const sumInt = function(a, b) {
    if(a > b) { return 0 }
    return a + sumInt(a+1, b);
};
#+END_SRC

Sum as reduce on a list
#+BEGIN_SRC javascript
const range = function(a, b) {
    return [...Array(b - a + 1).keys()].map(i => i + a);
};

const sumInt = function(a, b) {
    return range(a, b).reduce((acc, x) => acc + x, 0);
};
#+END_SRC


$$ \sum_{i=a}^{b} i^{2} $$

#+BEGIN_SRC scheme 
(define (sum-sq a b)
  (if (> a b)
      0
      (+ (square a)
      (sum-sq (+ 1 a) b))))
#+END_SRC

Now those two programs are almost identicle, the same first clause,
the same predicate, the same consequence, and the alternatives are very
similar too. The only difference is the A and the square of A.

What is similar here has to do with the Sigma notation and not depending
upon what is it adding up.

When you design complex systems and you want to be able to understand them,
it's crucial to divide the things up into as many pieces as you can, each
of which you understand separately.

$$ \sum_{i=a by 4}^{b} \frac{1}{i(i + 2)} $$

$$ \frac{1}{1 \dot 3} + \frac{1}{5 \dot 7} + \frac{1}{9 \dot 11} $$

converges to $\frac{\pi}{8}$ 

#+BEGIN_SRC scheme
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1 (* a (+ a 2)))
         (pi-sum (+ 4 a) b))))
#+END_SRC

When you learn a language you also leearn common patterns of usage.
You learn ideoms, useful things to know at a flash (they are often hard
to think out on your self).

In scheme you can not only know that, but you can also give the knowledge
of that a name. 

The pattern:
#+BEGIN_SRC scheme
;;(define (<name> a b)
;;  (if (> a b)
;;      0
;;      (+ (<term> a)
;;         (<name> (<next> a) b))))
#+END_SRC

Numbers are not special, they are just one kind of data.
You must be able to give all sorts of names to all kinds of data,
like procedures. Many languages allow procedural arguments.

#+BEGIN_SRC scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term
              (next a)
              next
              b))))

(sum (lambda (x) (* x x)) 1 (lambda (x) (+ 1 x)) 4)

;; as in the video lecture
(define (sum-int a b)
  (define (identity a) a)
  (sum identity a (+ 1 a) b))

;; helpers diverging from the original
(define (identity x) x)
(define (square x) (* x x))
(define (inc x) (+ 1 x))

(define (sum-sq a b)
  (sum square a inc b))

(define (pi-sum a b)
  (sum (lambda (i) (/ 1 (* i (+ i 2))))
       a
       (lambda (i) (+ 4 i))
       b))
#+END_SRC

With js, but not in tail position
#+BEGIN_SRC javascript 
const sum = function(term, a, next, b) {
    if(a > b) { return 0; }
    return term(a) + sum(term, next(a), next, b);
};

const identity = x => x;
const square = x => x * x;
const inc = x => x + 1;

const sumInt = function(a, b) {
    return sum(identity, a, inc, b);
};

const sumSq = function(a, b) {
    return sum(square, a, inc, b);
};
#+END_SRC

As a reduce on list
#+BEGIN_SRC javascript
const range = function(a, b, next) {
    return [...Array(b - a + 1).keys()].map( x => next(x));
};

const sum = function(term, a, next, b) {
    return range(a, b, next).reduce((acc, x) => {
        return acc + term(x);
    });
};
#+END_SRC

The invention of the procedure that takes a procedural argument, allows you
to compress a lot of these procedures into one thing.

Iterative implementation:
#+BEGIN_SRC scheme
(define (sum term a next)
  (define (iter j ans)
    (if (> j b)
        ans
        (iter (next j)
              (+ (term j) ans))))
  (iter a 0))
#+END_SRC

Iterative implementation for some reasom might be better than the recursive,
but the important thing is that it is different. But the recursive way
allows for decomposition. To independantly change one part of the program
without affecting the other part that was written for some other cases.

** 2a.2
"Computers to make people happy, not people to make computers happy."

Babylonian method for finding square root
#+BEGIN_SRC scheme
(define (sqrt x)
  (define tolerance 0.00001)
  (define (good-enuf? y)
    (> (abs (- (* y y) x)) tolerance))
  (define (improve y)
    (average (/ x y) y))
  (define (try y)
    (if (good-enuf? y)
        y
        (try (improve y))))
   (try 1))
#+END_SRC

Look complicated, it is not obvious by looking at it what it is computing.

If y is a guess for a square root, then what we want is a function f
(this is a means of improvement):

$$ y \xrightarrow{\text{f}} \frac{y + \frac{x}{y}}{2} $$

Such that: 

$$ f(\sqrt{x}) = \sqrt{x} $$

If you subsitute $y$ with $\sqrt{x}$ you get $\sqrt{x}$.
We are looking for a fixed point of the function $f$.

A fixed point is a place which has the property that if you put it into the
function, you get the same value out.
Some functions have the property that you can find their fixed point by
iterating the function.

Following the theorem you can write the square root function and worry
about implemanting fixed-point later.
#+BEGIN_SRC scheme
(define (sqrt x)
  (fixed-point (lambda (y) (average (/ x y) y))
  1))
#+END_SRC

#+BEGIN_SRC scheme
(define (fixed-point f start)
  (define tolerance 0.00001)
  (define (close-enuf? u v)
    (< (abs (- u v)) tolerance))
  (define (iter old new)
    (if (close-enuf? old new)
        new
        (iter new (f new))))
  (iter start (f start)))
#+END_SRC

#+BEGIN_SRC javascript
const average = (...args) => args.reduce((acc, x) => acc+x) / args.length;  

const sqrt = function(x) {
    return fixedPoint( y => average((x/y), y), 1);
};

const closeEnuf = function(u, v, tolerance = 0.00001) {
    return (Math.abs(u - v) < tolerance);
};

const fixedPoint = function(fn, start) {
   function iter(old, cur) {
      if(closeEnuf(old, cur)) {
          return cur;
      }
      return iter(cur, fn(cur));
   }
   return iter(start, fn(start));
};
#+END_SRC

There are other procedures which compute functions whose fixed point would
also be the square root.

$$ y \xrightarrow{\text{g}} \frac{x}{y}} $$

But if x = 2 and you start with 1 it oscillates between 1 and 2, and you
never get any closer to the square root. What you have is a signal
processing system that oscillates and you want to damp put these
oscillations. The average is avariging the last two values of something that
oscillates.

Average-damp is a special procidure that will take a procedure as its arg
and a procedure as its value.
#+BEGIN_SRC scheme
(define (sqrt x)
  (fixed-point
      (average-damp (lambda (y) (/ x y)))
      1))

(define (average-damp
  (lambda (f)
          (lambda (x) (average (f x) x)))))
#+END_SRC

#+BEGIN_SRC javascript
const sqrt = function(x) {
    return fixedPoint(averageDamp( y => x / y)(1));
};

const averageDamp = function(fn) {
    return function(x) {
        return average(fn(x), x);
    };
};

//const averageDamp = fn => x => average(fn(x), x);
#+END_SRC

** 2a.3
"... play with higher-order procedures ..."
"functions map values, procedures compute functions"

Newtons Method:
To find a $y$ such that $f(y) = 0$ 
start with a guess, $y_{0}$

$$ y_{n+1} = y_{n} - \frac{f(y_n)}{f'(y_{n})} $$

You need a function that is to be approximated in the form of $f(y) = 0$.
For example if you need the square root of x you can use $f(y)= x - y^{2}$
which is $x-y^{2} = 0$ or $y = \sqrt{x}$. And now you can use the newton's
method for approximating the value of the equation, which will be the
square root of x.

It is again looking for a fixed point of some procedure. It is more
complicated with those derivatives, but still you want to find the value
of y that will return the same value out of the function.

Top-down approach:
start by math concept, write a name for something, then worriey how to
implement it. Wishful thinking is essential to good engeneering(or cs).
#+BEGIN_SRC scheme
(define (sqrt x)
  (newton (lambda (y) (- x (square y)))))

(define (newton f guess)
  (define df (deriv f))
  (fixed-point
    (lambda (x) (- x (/ (f x) (df x))))
    guess))

(define deriv
  (lambda (f)
    (lambda (x) (/ (- (f (+ x dx))
                      (f x))
                    dx))))

(define dx 0.000001)
#+END_SRC


#+BEGIN_SRC javascript
const dx = 0.000001;

const sqrt = function(x) {
    return newton( y => x - square(y), 1);
};

const newton = function(fn, guess) {
    let df = deriv(fn);
    return fixed-point( x => x - (fn(x) / df(x)), 1);
};

const deriv = function(fn) {
    return function(x) {
        return (fn(x+dx) - fn(x)) / dx;
    };
};
#+END_SRC

Chris Strachey, ligicion one of the grandfathers of cs.
Envented denotational semantics. Great advocate of making procedures first
class citizens:
- to be named by variables
- to be passed as arguments to procedures
- to be returned as values of procedures
- to be incorporated into data structures

** 2B Compound Data

There was an absraction barrier between sqrt and good-enuf.
When we are building things we devorce the part of building things from
the task of implementing the parts. When you are building a complex
system you set a lot of abstraction barriers at a lot of levels.
Now we will do the same for data.

- the system has primitive data
- the system has  means of combination for data(glue to build more
- complicated, compound data from primitive data)
- a methodology for abstraction

Again the key idea is to build the system in layers and set abstraction
barriers that isolate the details at the lower layers from those in the
higher layers(so they can easily be someone elses' concern).

We will build a calculating system:

$$ \frac{1}{2} + \frac{1}{4} = \frac{3}{4},
\frac{3}{4} + \frac{2}{3} = \frac{1}{2}$$

$$ \frac{n_{1}}{d_{1}} + \frac{n_{2}}{d_{2}} = \frac{n_{1}d_{2}+n_{2}d_{1}}{d_{1}d_{2}},
\frac{n_{1}}{d_{1}} + \frac{n_{2}}{d_{2}} = \frac{n_{1}n_{2}}{d_{1}d_{2}} $$

Note that the system does not include rational numbers. Will will use the
strategy of wishful thinking.

Lets imagine that we have procedures that act like those:
#+BEGIN_SRC scheme
;; cloud is someting that has n and d
(make-rat n d) -> <cloud>

(numer <cloud>) -> n

(denom <cloud>) -> d
#+END_SRC



# template
#+BEGIN_SRC scheme

#+END_SRC
