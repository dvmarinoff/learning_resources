#+STARTUP: showall

* Do Things

** Syntax

simple like all Lisps, it employs:

a uniform structure,
a handful of special operators,
and a constant supply of parentheses

(delivered from the parenthesis mines hidden beneath the
Massachusetts Institute of Technology, where Lisp was born)

*** Forms

two kinds of structure:
 - literal representation
 - operations

literals are used inside operations(expressions)

(operator operand1 operand2 ... operandn)

*** Control Flow

if - boolean form

(if boolean-form
  then-form
  optional-else-form)

do - wraps multiple forms and runs each of them

when - combines if and do, but with no else branch

truthness - nil and false are used to represent logical falsiness,
           all other values are logically truthy

nil? - check if value is nil

or - returns the first truthy value

and - returns the last truhty value

#+BEGIN_SRC clojure

(if true
  "By Zeus's hammer!")

(if true
  (do (println "Success")
      "By Zeus's hammer!"))

(when true
  (println "Success!")
  "abra cadabra")

(or false nil :first :last)
#; => :first

(or (= 0 1) (= "yes" "no"))
#; => false

(and :first :last)
#; => :last

#+END_SRC

*** Naming Values with def

def - binds name to a value



#+BEGIN_SRC clojure

(def failed-protagonist-names
 ["Larry Potter" "Doreen the Explorer" "The Incredible Bulk"])

#+END_SRC
** Data Structures

*** Numbers

has pretty sophisticated numerical support
Here’s an integer, a float, and a ratio:
93
1.2
1/5

*** Strings

only double quotes

*** Maps

Maps are similar to dictionaries or hashes in other languages.
They’re a way of associating some value with some other value.
There are two kinds:

- hash maps

{}

{:first-name "Charlie"
 :last-name "McFishwich"}

{"string-key" +}

hash-map - function to create hashmap
get      - to look up values in maps
get-in   - look up values in nested map

or just use keywords to look up values

- sorted maps

#+BEGIN_SRC

(hash-map :a 1 :b 2)
#; => {:a 1 :b 2}

(get {:a 0 :b 1} :b)
#; => 1

(get-in {:a 0 :b {:c "ho hum"}} [:b :c])
#; => "ho hum"

({:name "Harry"} :name)
#; => "Harry"

# as well as with get with default value:
(:d {:a 1 :b 2 :c 3} "No gnome knows homes like Noah knows")
; => "No gnome knows homes like Noah knows"

#+END_SRC

*** Keywords

primarily used as keys in maps:

:a
:rumplestiltsken
:34
:_?

*** Vectors

0-indexed collection with fast random place access times

[3 2 1]

get    - again uses get to access values
vector - function to create vectors
conj   - add elements to the end

#+BEGIN_SRC clojure

(get [3 2 1] 0)
#; => 3

(vector "creepy" "full" "moon")
#; => ["creepy" "full" "moon"]

(conj [1 2 3] 4)
#; => [1 2 3 4]

#+END_SRC

*** Lists

linked-lists

A good rule of thumb is that if you need to easily add items
to the beginning of a sequence or if you’re writing a macro,
you should use a list. Otherwise, you should use a vector

nth  - to retrieve element from a list (cannot use get)
      much slower than get for vectors

list - a function to create lists
conj - adds elements to the beginning of a list

#+BEGIN_SRC clojure

'(1 2 3 4)
#; => (1 2 3 4)

(nth '(:a :b :c) 0)
#; => :a

(conj '(1 2 3) 4)
#; => (4 1 2 3)

#+END_SRC

*** Sets

Sets are collections of unique values. Clojure has two kinds of sets:
- hash sets

hash-set  - a function to create a hash-set
set       - create sets from existing vectors and lists
conj      - add to a set
contains? - check for membership
get       - to look up value

- sorted sets

#+BEGIN_SRC clojure

#{"kurt vonnegut" 20 :icicle}

(hash-set 1 1 3 3)
#; => #{1 2}

(set [3 3 3 3 4 4 4 4])
#; => #{3 4}

(contains? #{:a :b} :a)
#; => true

#+END_SRC

*** Simplicity

It is better to have 100 functions operate on one data structure
than 10 functions on 10 data structures.
—Alan Perlis

** Functions


*** Calling Functions



*** Function Calls, Macro Calls, and Special Forms

*** Defining Functions

Function definitions are composed of five main parts:

- defn
- Function name
- A docstring describing the function (optional)
- Parameters listed in brackets
- Function body

**** arity overloading

used to define default behavior or do something completely unrelated

**** rest parameter

&

**** Destructuring

You can retain access to the original map argument by using the :as keyword

**** Function Body

The function body can contain forms of any kind.
Clojure automatically returns the last form evaluated

#+BEGIN_SRC clojure

(defn too-enthusiastic
  "Return a cheer that might be a bit too enthusiastic"
  [name]
  (str "OH. MY. GOD! " name " YOU ARE MOST DEFINITELY LIKE THE BEST "
  "MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE"))

(defn multi-arity
  ([first-arg second-arg third-arg]
     (do-things first-arg second-arg third-arg))
  ([first-arg second-arg]
     (do-things first-arg second-arg))
  ([first-arg]
     (do-things first-arg)))

(defn codger
  [& whippersnappers]
  (map codger-communication whippersnappers))

(defn chooser
  [[first-choice second-choice & unimportant-choices]]
  (println (str "Your first choice is: " first-choice))
  (println (str "Your second choice is: " second-choice))
  (println (str "We're ignoring the rest of your choices. "
                "Here they are in case you need to cry over them: "
                (clojure.string/join ", " unimportant-choices))))

(defn illustrative-function
  []
  (+ 1 304)
  30
  "joe")

; => "joe"

#+END_SRC

*** Anonymous Functions

fn form - creates anonymous function
        - works as defn
        - can be associated with name using defn

(fn [param-list]
  function body)

(def my-special-multiplier (fn [x] (* x 3)))

compact form - % and %1, %2, %3 are param placeholders
             - made possible by a feature called reader macros

#(* % 3)


*** Returning Fuctions

** Pulling It All Together

let   -

loop  -

recur -

* Core Functions

** Programming to Abstractions

*** Treating Lists, Vectors, Sets, and Maps as Sequences

*** first, rest, and cons

*** Abstruction Through Indirection

** Seq Function Examples

*** map

*** reduce

*** filter and some

*** sort and sort-by

*** concat

** Lazy Seqs

*** Demonstrating Lazy Seq Efficiency

*** Infinite Sequences

** The Collection Abstraction

*** into

*** conj

** Function Functions

*** apply

*** partial

*** complement

** A Vampire Data Analysis Program for the FWPD

* Functional Programming

** Pure Functions: What and Why

*** Pure Functions Are Referentially Transparent

*** Pure Functions Have No Side Effects

** Living with Immutable Data Structures

*** Recursion Instead of for/while

*** Function Composition Instead of Attribute Mutation

** Cool Things to Do with Pure Functions

*** comp

*** memoize

** Peg Thing

*** Playing

*** Code Organization

*** Moving Pegs
