'----------'
1.Introduction
'----------'

'----------'
2. Welcome
'----------'

2.1. Form
    - toplevel - interactive front-end
    (+ 3 4)
    - + - operator; 3,4 - arguments = prefix notation
    - all expressions are atoms like 1 or lists (/ (- 7 1) (- 4 2))
    - single notation to express all ideas
2.2. Evaluation
    (+ 3 4)
    - + is a function and the expression is a function call. It evaluetes in two steps:
        - arguments are evaluated from left to right,
        - values of the arguments are passed to the function named by the operator.
    - this is known as the lisp evaluation rule
    - not all operators are functions, but most are
    - :abort - to get out of the message
    - Special operator:
        - quote or ' - does not follow the evaluation rules, just does nothing. Protects expressions from evaluating.
        (quote (+ 3 4))
        (' (+ 3 4))
2.3. Data
    - all data types + few more
    - common:
        - integers,
        - strings in ""
    - not common:
        - Symbols - are words converted to uppercase, do not (usually) evaluate to themselves.
        So  there are refered with quote.
        - Lists - 0 || > elements in (). Can be of any type even lists. They have to be in quote or
        lisp would take them for function calls.
        '(my 3 "Sons")
        '(the list (a b c) has 3 elements)
                - quote also protects expresions within
                - the list operator can build lists
        (list 'my (+ 2 1) "Sons")
        (My 3 "Sons")
                - empty list is:
        () or nil
2.4. List Operations
    - cons - builds lists by adding the first argument to the list, which must come as a second argument.
        (cons 'a '(b c d)) -
        (cons 'a (cons 'b nil))
       (A B)
    - list - the list function is just a more convenient way of consing several things to nil.
        (list 'a 'b)
        (A B)
    - car - extract first element
        (car '(a b c))
        > A
    - cdr - extract everything after the first
        (cdr '(a b c))
        > (A B)
          - both can be used to extract any value:
        (car (crd (cdr '(a b c d))))
        > C
    - third - extract the third
2.5. Truth
    - t - is the default symbol for truth
    - predicate - a function whose return value is truth or falsity. Often ends in p.
    - listp - returns true if argument is list
    (listp '(a b c))
    > T
    - null - return true if argument is empty list
    (null nil)
    > T
    - nil - falsity in lisp, the empty list. Everything else counts as true in logical context.
    - not - function returns true if argument is false
    (null nil) and (not nil)
    > T
    - if - special operator, because it needs to evaluate just one of its arguments. Last is optional.
        (if (listp '(a b c)))
            (+ 1 2)
            (+ 5 6)
        > 3
    - and - resemble conditionals, take any number of arguments, evaluates the last if true
    - or - same, but stops as soon as it finds true

    - These two are called macros. Like special operators, macros can circumvent the usual evaluation rule.
2.6. Functions
    - defun - defines new functions. Takes 3 or > arguments: name, list of parameters and 1 or >
    expressions that form the body of the function.

        - custom third:
    (defun our-third (x)
        (car (cdr (cdr x))))
    > OUR-THIRD
    - x - a symbol used as a placeholder in this way is called a variable.
        When it represents an argument to a function it is also a parameter.
        - a list has to be quoted else is treated as code
        a symbol has to be quoted else is treated as variable
    - Lisp makes no distiction between a program, a procedure, and a function.
    Functions do for everyting and make up most of the language itself.
2.7. Recursion
    - function may call other functions, a function that call itself is recursive.
    - custom member:
    (defun our-member (obj lst)
        (if (null lst)
            nil
            (if (eql (car lst) obj)
                lst
                (our-member obj (cdr lst)))))
    - eql - predicate that tests whether its two arguments are identical

    - functions are not like a sort of machine, but more like process. Not machine, a set of rules.
2.8. Reading Lisp
    - turn on paren-matcing for code editor
    - use identation to ease reading
2.9. I/O
    - format - most general output.
             - first: whether to print the output
             - second: string template. ~A is position to be filled, ~% is a newline.
             - remaining arguments usualy inserted into the template.
    (format t "~A plus ~A equals ~A.~%" 2 3 (+ 2 3))
    > 2 plus 3 equals 5
    > NIL
        - first is displayed by format second returned by the call to format.
    - read - standart for input. Very powerful, because is complete lisp parser.
            Parses what it reads and returns lisp objects that results.
    (defun askem (string)
        (format t "~A" string)
        (read))
    > How old are you? 29
    > 29

    - side-effect - is some change to the state of the world that happens as a consequence of evaluating an expression.
        When we call format, as well as returning a value, it prints something, that's one kind of side-effect.
        Only value of last expression is returned by the function and values of any proceeding expressions are thrown away.
        If such expressions didn't have side-effects, you would jave no way of telling whether lisp bothered
        to evaluate them at all.
2.10. Variables
    - let - intoduces new local variables.They are valid only in the body of the let.
    (let ((x 1) (y 2))
        (+ x y))
    > 3

    (defun ask-number ()
        (format t "Please enter a number. ")
        (let ((val (read)))
            (if (numberp val))
                val
                (ask-number)))
    - global variables with defparameter and *glob* convesion, because they are overwritten by
     local variales with same name.
    (defparameter *glob* 99)
    - constants with defconstant
    (defconstant limit (+ *glob* 1))
2.11. Assignment
    -setf - the general assaignment operator
    (setf *glob* 98)
    > 98
    (let ((n 10))
        (setf n 2)
        n)
    > 2
    - when first argument is symbol that is not the name of a local variable,
    it is taken to be a global variable.
    (setf x (list 'a 'b 'c))
    > (A B C)
2.12. Functional Programming
    - means writing programs that work br returning values, insted of by modifying things.
    - remove - for example, takes an object and a list and return a new list without the object.
    (setf lst '(c a r a t))
    > (C A R A T)
    (remove 'a lst)
    > (C R T)
    - the original list remains untouched, but if you really do want to remove something
    from a list you pass it to a function and use setf with return value.
    - but you need to essentiakky avoid setf.
    - interactive testing is great advantage.
2.13. Iteration
    - do - the fundamential iteration operator. Like let it creates variables.
     The first argument is a list of variable specifications, and each element is of the form:

    (variable initial update)

    - variable is a symbol, and initial and update are expressions.
    (defun show-squares (start end)
        (do ((i start (+ i 1)))
            ((> i end) 'done)
            (format t "~A ~A ~%" i (* i i))))

    (show-squares 2 5)
    > 2 4
    > 3 9
    > 4 16
    > 5 25
    > DONE

    - recursive version:
    (defun show-squares (i end)
        (if (> i end)
            'done
            (progn
                (format t "~A ~A~%" i (* i i))
                (show-squares (+ i i) end))))
    - progn - takes any number of expressions, evaluates them and returns the value of the last.
    - Most of the time simpler iteration operators for special cases are used.
    - dolist - takes argument of the form:
            (variable expression)
            , followed by a body of expresions.
    (defun our-length (lst)
        (let ((len 0))
            (dolist (obj lst)
                (setf len (+ len 1)))
            len))

2.14. Functions and Objects
    - functions are regular objects. They can be passed as arguments to functions.
    - apply -
2.15. Types
2.16. Looking Forward

'----------'
3. Lists
'----------'

'------------'
10. Macros
'------------'
10.1. Eval


'----////-----------\\\\----'
           CLOJURE
'----////-----------\\\\----'

'----------'
1.Getting started
'----------'

1.1.Why Clojure

1.2.Quick Start
    (println "hello worls")
    > hello world
    > nil

    (defn greet [name] (str "Hello, " name))
    > #'user/hello

    - defn - defines a function
    - greet - name of the function
    - [name] - name is argument of the function, arguments are passed in vectors rather then lists for readability
    - str - function that concatenates an arbitrary list of arguments into a string
    - #' - indecates that the function was stored in a clojure var
    - user/hello - the namespace (user is the default namespace for the repl)

    (greet "Stu")
    > Hello, Stu

    - special variables:
        - *1, *2 and *3 - store the results of the most recently evaluated expressions
        (str *1 " and " * 2)
        > Hello, Clojure and Hello, Stu

        - *e - holds the last exeption, also printStackTrace() from Java can be called
        (/ 3 0)
        > java.lang.ArithmeticExeption: Devide by zero
        (.printStackTrace *e)
        > java.lang.ArithmeticExeption: Devide by zero

    - you can load code from file in the repl
    (load-file "main.clj")

    - adding shared state:
        - most programs have some shared state and will use impure functions to manage it.

    - #{} - literal for an empty set
    - conj - short for conjoin and it builds new collection with an item added
    (conj #{} "Stu")
    > #{"Stu"}

    - ref - references
    - def - like defn, but works for functions or data
    - alter - update a reference

    (def visitors (ref #{}))
    - creates a reference, and binds it to the name visitors

    - alter
        - r - reference, update-fn - the function to be applied, args - optional aggs to the function
    (alter r update-fn & args)

    (alter visitors conj "Stu")
    => java.lang.IllegalStateException: No transaction running

    - clojure protects references and they must be updated in a transaction

    - dosync - creates a transaction
    (dosync & exprs)

    (dosync (alter visitors conj "Stu"))
    => #{"Stu"}

    - deref - or just @ - to peek at the reference
    (deref visitors)
    @visitors
    => #{"Stu"}

    (defn hello
        "Writes hello message to *out*. Calls you by username. Knows if you have been here before."
        [username]
        (dosync
            (let [past-visitor (@visitors username)]
                (if past-visitors
                    (str "Welcome back, " username)
                    (do
                        (alter visitors conj username)
                        (str "Hello, " username))))))

1.3.Exploring Clojure Libraries

1.4.Introducing Lancet

1.5.Wrapping Up












////
// 
////
 - macros allow Clojure to derive a lot of its build in functionality
 from a tiny core of functions and special forms.

 - when is not a special form, but a macro

(macroexpand '(when boolean-expression
	        expression-1
		expression-2
		expression-3))

(defmacro infix
  "rearranges a list into the correct order for infix notation"
  [infixed]
  (list (second infixed) (first infixed) (last infixed)))

(infix (1 + 1))
; => 2

 - one key difference between functions and macros is that function
 arguments are fully evaluated before they're past to the function,
 and macros receive arguments as unevaluated data

 - use macroexpand to see code

(macroexpand '(infix (1 + 1)))
; => (+ 1 1)

 - with arguments destructuring

(defmacro infix-2
  [[operand1 op operand2]]
  (list op operand1 operand2))

 - multiple arity macro
 
(defmacro and
  "Evaluates exprs one at a time, from left to right."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))





























